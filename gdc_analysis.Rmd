---
title: "Uncovering Drivers of Intra Tumoral Heterogeneity"
output: html_document
---
***
# SNV data

The first thing to do is get the data into the environment. Since the data is in several folders in the "SNV" folder, I'm using the "MANIFEST.txt" file to get all the file paths. This file also includes the annotations' file paths but I'm only interested in the data tables (".maf.gz" files).
```{r paths}
paths <- as.character(read.table("SNV/MANIFEST.txt", header = TRUE)$filename)
paths <- paths[substr(paths, nchar(paths) - 1, nchar(paths)) == "gz"]
paths <- paste("SNV/", paths, sep = "")

paths[1] # Since each path has this structure:
```
```{r cancer types}
# We do the following to get the cancer types:
cancer_types <- unname(sapply(sapply(paths, strsplit, "[.]"), "[[", 2))
                            # Splitting each path by "."
                    # Getting the second element of each split outcome
              # Unname for simplicity sake

cancer_types # Resulting in:
```

Having the file paths and cancer types we can finnaly create a list of data frames, each for each cancer.
```{r SNV_data}
# SNV_data <- lapply(paths, read.table, sep = "\t", header = TRUE, quote = "")
# names(SNV_data) <- cancer_types
# save(x = SNV_data, file = "SNV_data.RData")
# load("SNV_data.RData")
```
Since this process takes a while, I saved the SNV_data object in a file that could be loaded when needed.

# First approach

Since we are studying Intra Tumoral Heterogeneity, we'll have to calculate a unit of it, such as mutant-allele tumor heterogeneity (MATH). For this I'll create a function that takes the data of one cancer and returns a data frame with the calculated MATH for each tumor sample.

To calculate the MATH value of each tumor, one must calculate the mutant-allele fraction (MAF) values of all the somatic mutations in the tumor, like so:
$$MAF=\frac{t\_alt\_count}{t\_depth}$$
Where t_alt_count represents the number of mutated alleles and t_depth is the total amount of alleles.

Next, we calculate the median absolute deviation (MAD) value of the tumor:
$$MAD=\frac{1.4826}{n} \sum_{i=1}^{n}\left( \left\lvert{ MAF_{i}-\frac{1}{n} \sum_{i=1}^{n}(MAF_{i}) }\right\rvert \right)$$
Which is multiplied by a factor of 1.4826 "so that the expected MAD of a normally distributed variable is equal to its standard deviation".

And finally, the MATH value, which is "the percentage ratio of the MAD to the median distribution of MAFs among the tumor's genomic loci":
$$MATH=\frac{100MAD}{\frac{1}{n} \sum_{i=1}^{n}(MAF_{i})}$$

```{r MATH}
MATH_calculator <- function(interest_data){ # interest_data is the data.frame read from the raw text file
  # Calculating MAF for each mutation
  interest_data$MAF <- with(interest_data, t_alt_count / t_depth)
  
  # Calculating MATH for each tumor
  MATH_data <- aggregate(interest_data$MAF,
                         by = list(interest_data$Tumor_Sample_Barcode),
                         function(MAF){
                           MAD <- median(abs(MAF - median(MAF))) * 1.4826
                           MATH <- 100 * MAD / median(MAF)
                           return(MATH)})
  names(MATH_data) <- c("Tumor_Sample_Barcode", "OUTPUT")
  return(MATH_data)
}
```
Where the OUTPUT corresponds to MATH values.

Given the number of genes, it is convenient to sort them by groups that make sense from a biological point of view in order to do a linear model that explains the variation of ITH.
```{r Gene List}
pathways_list <- list(
  Transcription_factor = list("FOXA2", "CEBPA", "VEZF1", "SOX9", "PHF6", "EIF4A2", "WT1", "SIN3A", "EP300", "TBX3", "MECOM", "RUNX1", "TSHZ2", "TAF1", "CTCF", "TSHZ3", "GATA3", "VHL"),
  EpigeneticMod = list("EZH2", "ASXL1", "ARID5B", "MLL4", "KDM6A", "KDM5C", "SETBP1", "NSD1", "SETD2", "PBRM1", "ARID1A", "MLL2", "MLL3", "TET1", "TET2", "DNMT3A", "DNMT3B", "DNMT1", "HIST1H1C", "HIST1H2BD", "H3F3C"), # remove "TET1", "DNMT3B", "DNMT1"??
  Genome_integrity = list("ERCC2", "CHEK2", "SMC3", "SMC1A", "BRCA1", "BAP1", "STAG2", "ATR", "BRCA2", "ATRX", "ATM", "TP53"),
  RTK_signalling = list("FGFR3", "KIT", "FGFR2", "EPHB6", "PDGFRA", "ERBB4", "EPHA3", "FLT3", "EGFR"),
  Cell_cycle = list("CDKN2C", "CDKN1A", "CDK12", "RB1", "CDKN2A"),
  MAPK_signalling = list("MAPK8IP1", "BRAF", "MAP3K1", "NF1", "KRAS"),
  PIK_signalling = list("AKT1", "PIK3CG", "TLR4", "PIK3R1", "PTEN", "PIK3CA"),
  TGFB_signalling = list("ACVR2A", "SMAD2", "ACVR1B", "TGFBR2", "SMAD4"),
  Wnt_BCatenin_signalling = list("TBL1XR1", "AXIN2", "CTNNB1", "APC"),
  Proteolysis = list("SPOP", "KEAP1", "FBXW7"),
  Splicing = list("PCBP1", "SF3B1"),
  HIPPO_signalling = list("CDH1"),
  Metabolism = list("IDH2", "IDH1"),
  NFE2L = list("NFE2L3", "NFE2L2"),
  Protein_phosphatase = list("PTPN11", "PPP2R1A"),
  Ribosome = list("RPL5", "RPL22"),
  TOR_signalling = list("STK11", "MTOR")
  )
```

For the linear model, the response (y) will be the measure of ITH, MATH and the predictors (x) will be the groups of genes as binary variables, taking the value of 1 if there is a mutation in at least one of the genes in the group and 0 if not. This way we can model the variance of ITH and find which group of genes is more correlated with it.

To this end, I'll need a function that does the following:
1. Groups the mutated genes per tumor
2. 
```{r Binary variables}
binary_variables <- function(interest_data, gene_group){
  genes_per_tumor <- aggregate(interest_data$Hugo_Symbol,
                          by = list(interest_data$Tumor_Sample_Barcode),
                          function(genes){as.character(genes)})
  
  variables <- t(sapply(apply(genes_per_tumor[2],
                              1,
                              function(x){
                                sapply(unlist(x),
                                       function(y){
                                         sapply(gene_group,
                                                function(z){
                                                  y%in%z
                                                  }
                                                )
                                         }
                                       )
                                }
                              ),
                        function(x){
                          apply(x,
                                1,
                                function(x){
                                  sum(x)>0
                                  }
                                )
                          }
                        )
                 )
  
  MATH_data <- MATH_calculator(interest_data)
  
  final_data<-cbind(MATH_data,variables)[,-c(1)]
  return(final_data)
}

# Exclude silent mutations
delete_silent <- function(interest_data, gene_group){
  silent_consequences<-c("3_prime_UTR_variant", "5_prime_UTR_variant", "downstream_gene_variant", "intergenic_variant",
                         "intron_variant", "non_coding_transcript_exon_variant", "synonymous_variant", "upstream_gene_variant")
  not_silent<-interest_data[!interest_data$One_Consequence%in%silent_consequences,]
  not_silent_final <- binary_variables(not_silent, gene_group)
  return(not_silent_final)
}
```

# Adjusted R squared, Coefficient matrix and pheatmap

```{r}
# Process data
process <- function(data, gene_group){
  processed_data <- list()
  for (i in 1:length(data)){
    processed_data[[cancer_types[i]]] <- delete_silent(data[[i]], gene_group)
  }
  return(processed_data)
}

# R_list
adj_r_sqrd <- function(processed_data){
  r_list <- numeric(length(processed_data)); names(r_list) <- cancer_types
  for (i in 1:length(processed_data)){
    fit <- lm(OUTPUT ~ ., data=processed_data[[i]])
    adj_r_sqrd <- (summary(fit)$adj.r.squared)
    r_list[i] <- adj_r_sqrd
  }
  return(r_list)
  }

# Coef_Matrix
coef_matrix <- function(processed_data){
  coef_matrix <- matrix(NA, nrow = length(paths), ncol = length(processed_data[[1]])-1, dimnames = list(cancer_types,
                                                                                                  names(processed_data[[1]])[-1]))
  for (i in 1:length(processed_data)){
    fit <- lm(OUTPUT ~ ., data=processed_data[[i]])
    coef <- as.data.frame(summary(fit)$coef)
    coef <- coef[-c(1),]
    sig <- coef[coef$`Pr(>|t|)`<.05,]
    if (nrow(sig) > 0){
      for (j in 1:nrow(sig)){
        rname <- row.names(sig)[j]
        rname <- substr(rname,1,nchar(rname)-4)
        coef_matrix[i,rname]<-sig[j,1]
      }
    }
  }
  return(coef_matrix)
}

# Plots
library(gplots) # bluered
library(pheatmap)

plotting <- function(processed_data){
  Adjusted_R_Squared<-adj_r_sqrd(processed_data)
  CoefMatrix<-coef_matrix(processed_data)
  pheatmap(CoefMatrix,
           cluster_rows = FALSE,
           cluster_cols = FALSE,
           color = bluered(9),
           annotation_row = as.data.frame(Adjusted_R_Squared),
           angle_col = 315,
           breaks = c(seq(min(CoefMatrix,na.rm = T),0,length=5),seq(0.000001,max(CoefMatrix,na.rm = T),length=5)),
           na_col = 0
           )
}

# Standardizing the MATH values
standardize <- function(processed_data){
  standardized_data <- list()
  for (i in 1:length(processed_data)){
    standardized_data[[i]] <- cbind(scale(processed_data[[i]][1]),processed_data[[i]][-c(1)])
  }
  return(standardized_data)
}
```

# Results
## SNV-pathways vs SNV-geneSets

```{r}
# SNV_pathways <- process(SNV_data, pathways_list)
# save(x=SNV_pathways, file = "SNV_pathways.RData")
load("SNV_pathways.RData")

plotting(SNV_pathways)
plotting(standardize(SNV_pathways))

# Different grouping of genes
load("geneSets.Rdata")
for (i in 1:length(geneSets)){
  geneSets[[i]]<-as.list(geneSets[[i]][1][,1])
}

# SNV_geneSets <- process(SNV_data, geneSets)
# save(x=SNV_geneSets, file = "SNV_geneSets.RData")
load("SNV_geneSets.RData")

plotting(SNV_geneSets)
plotting(standardize(SNV_geneSets))
```
