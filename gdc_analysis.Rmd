---
title: "Uncovering Drivers of Intra Tumoral Heterogeneity"
output: html_document
---
***
# SNV data

The first thing to do is get the data into the environment. Since the data is in several folders in the "SNV" folder, I'm using the "MANIFEST.txt" file to get all the file paths. This file also includes the annotations' file paths but I'm only interested in the data tables (".maf.gz" files).
```{r paths}
paths <- as.character(read.table("SNV/MANIFEST.txt", header = TRUE)$filename)
paths <- paths[substr(paths, nchar(paths) - 1, nchar(paths)) == "gz"]
paths <- paste("SNV/", paths, sep = "")

paths[1] # Since each path has this structure:
```
```{r cancer types}
# We do the following to get the cancer types:
cancer_types <- unname(sapply(sapply(paths, strsplit, "[.]"), "[[", 2))
                            # Splitting each path by "."
                    # Getting the second element of each split outcome
              # Unname for simplicity sake

cancer_types # Resulting in:
```

Having the file paths and cancer types we can finnaly create a list of data frames, each for each cancer.
```{r SNV_data}
# SNV_data <- lapply(paths, read.table, sep = "\t", header = TRUE, quote = "")
# names(SNV_data) <- cancer_types
# save(x = SNV_data, file = "SNV_data.RData")
# load("SNV_data.RData")
```
Since this process takes a while, I saved the SNV_data object in a file that could be loaded when needed.

# First approach

Since we are studying Intra Tumoral Heterogeneity, we'll have to calculate a unit of it, such as mutant-allele tumor heterogeneity (MATH). For this I'll create a function that takes the data of one cancer and returns a data frame with the calculated MATH for each tumor sample.

To calculate the MATH value of each tumor, one must calculate the mutant-allele fraction (MAF) values of all the somatic mutations in the tumor, like so:
$$MAF = \frac{t\_alt\_count}{t\_depth}$$
Where t_alt_count represents the number of mutated alleles and t_depth is the total amount of alleles.

Next, we calculate the median absolute deviation (MAD) value of the tumor:
$$MAD = \frac{1.4826}{n} \sum_{i = 1}^{n} \left( \left\lvert{ MAF_{i} - \frac{1}{n} \sum_{i = 1}^{n} (MAF_{i}) }\right\rvert \right)$$
Which is multiplied by a factor of 1.4826 "so that the expected MAD of a normally distributed variable is equal to its standard deviation".

And finally, the MATH value, which is "the percentage ratio of the MAD to the median distribution of MAFs among the tumor's genomic loci":
$$MATH = 100 \frac{MAD}{\frac{1}{n} \sum_{i = 1}^{n} (MAF_{i})}$$

```{r MATH}
MATH_calculator <- function(cancer_data){
  # Calculating MAF for each mutation
  cancer_data$MAF <- with(cancer_data, t_alt_count / t_depth)
  
  # Calculating MATH for each tumor
  MATH_data <- aggregate(cancer_data$MAF,
                         by = list(cancer_data$Tumor_Sample_Barcode),
                         function(MAF){
                           MAD <- median(abs(MAF - median(MAF))) * 1.4826
                           MATH <- 100 * MAD / median(MAF)
                           return(MATH)})
  names(MATH_data) <- c("Tumor_Sample_Barcode", "OUTPUT")
  return(MATH_data)
}
```
Where the OUTPUT corresponds to MATH values.

Given the number of genes, it is convenient to sort them by groups that make sense from a biological point of view in order to do a linear model that explains the variation of ITH. Here we use a list of 17 pathways with a total of 101 genes.
```{r Gene List}
pathways_list <- list(
  Transcription_factor = list("FOXA2", "CEBPA", "VEZF1", "SOX9", "PHF6", "EIF4A2", "WT1", "SIN3A", "EP300", "TBX3", "MECOM", "RUNX1", "TSHZ2", "TAF1", "CTCF", "TSHZ3", "GATA3", "VHL"),
  EpigeneticMod = list("EZH2", "ASXL1", "ARID5B", "MLL4", "KDM6A", "KDM5C", "SETBP1", "NSD1", "SETD2", "PBRM1", "ARID1A", "MLL2", "MLL3", "TET1", "TET2", "DNMT3A", "DNMT3B", "DNMT1", "HIST1H1C", "HIST1H2BD", "H3F3C"), # remove "TET1", "DNMT3B", "DNMT1"??
  Genome_integrity = list("ERCC2", "CHEK2", "SMC3", "SMC1A", "BRCA1", "BAP1", "STAG2", "ATR", "BRCA2", "ATRX", "ATM", "TP53"),
  RTK_signalling = list("FGFR3", "KIT", "FGFR2", "EPHB6", "PDGFRA", "ERBB4", "EPHA3", "FLT3", "EGFR"),
  Cell_cycle = list("CDKN2C", "CDKN1A", "CDK12", "RB1", "CDKN2A"),
  MAPK_signalling = list("MAPK8IP1", "BRAF", "MAP3K1", "NF1", "KRAS"),
  PIK_signalling = list("AKT1", "PIK3CG", "TLR4", "PIK3R1", "PTEN", "PIK3CA"),
  TGFB_signalling = list("ACVR2A", "SMAD2", "ACVR1B", "TGFBR2", "SMAD4"),
  Wnt_BCatenin_signalling = list("TBL1XR1", "AXIN2", "CTNNB1", "APC"),
  Proteolysis = list("SPOP", "KEAP1", "FBXW7"),
  Splicing = list("PCBP1", "SF3B1"),
  HIPPO_signalling = list("CDH1"),
  Metabolism = list("IDH2", "IDH1"),
  NFE2L = list("NFE2L3", "NFE2L2"),
  Protein_phosphatase = list("PTPN11", "PPP2R1A"),
  Ribosome = list("RPL5", "RPL22"),
  TOR_signalling = list("STK11", "MTOR")
  )
```

For the linear model, the response (y) will be the measure of ITH, MATH and the predictors (x) will be the groups of genes as binary variables, taking the value of 1 if there is a mutation in at least one of the genes in the group and 0 if not. This way we can model the variance of ITH and find which group of genes is more correlated with it.

To this end, I'll need a function that:
1. Groups the mutated genes per tumor
2. Checks if each of those genes is in each gene group
3. For each tumor, informs if there is at least one mutated gene in each gene group 
```{r Binary variables}
binary_variables <- function(cancer_data, gene_group){
  genes_per_tumor <- aggregate(cancer_data$Hugo_Symbol,
                          by = list(cancer_data$Tumor_Sample_Barcode),
                          function(genes){as.character(genes)})
  
  variables <- t(sapply(apply(genes_per_tumor[2], # Each tumor
                              1, function(gene_list){sapply(unlist(gene_list), # corresponds to a list of genes we'll go through
                                                            function(gene){sapply(gene_group, # and for each group in gene_group, 
                                                                                  function(group){gene %in% group
                                                                                    # we check if the gene is in that group.
                                                                                    })})}),
                        # Now that we have a list of data frames that cross each tumor's mutated genes with the given groups, 
                        function(x){apply(x, 1, # we'll go through each data frame and for each tumor's row (gene group)
                                          function(x){sum(x) > 0 # we calculate the sum and if it is greater than 0, 
                                            })})) # then there is a mutated gene from that group in that tumour.
  # Since we want the gene groups to be columns and not rows, the last thing to do is transpose the matrix.
  
  MATH_data <- MATH_calculator(cancer_data) # And with the MATH values added, we have everything needed for the model.
  final_data <- cbind(MATH_data, variables)[, -c(1)] # We take out the first column because we don't need the tumor sample codes.
  return(final_data)
}
```
Where each row represents a tumor sample.

Another important thing to do is to exclude silent mutations since those won't actually affect ITH.
```{r Exclude silent mutations}
delete_silent <- function(cancer_data, gene_group){
  silent_consequences <- c("3_prime_UTR_variant", "5_prime_UTR_variant", "downstream_gene_variant", "intergenic_variant", "intron_variant", "non_coding_transcript_exon_variant", "synonymous_variant", "upstream_gene_variant")
  not_silent <- cancer_data[!cancer_data$One_Consequence %in% silent_consequences, ]
  not_silent_final <- binary_variables(not_silent, gene_group)
  return(not_silent_final)
}
```

# Final functions

Now that I've developed the functions to process each individual cancer data frame, it's time to apply them to all of them.
```{r Process data}
process <- function(data, gene_group){
  processed_data <- list()
  for (i in 1:length(data)){
    processed_data[[cancer_types[i]]] <- delete_silent(data[[i]], gene_group)
  }
  return(processed_data)
}
```
Next we'll calculate the adjusted R squared for each processed data frame's linear model as well as all of the significant coefficients in order to efficiently see and compare our results.
```{r Adjusted R squared}
adj_r_sqrd <- function(processed_data){
  r_list <- numeric(length(processed_data)); names(r_list) <- cancer_types
  for (i in 1:length(processed_data)){
    fit <- lm(OUTPUT ~ ., data = processed_data[[i]])
    adj_r_sqrd <- summary(fit)$adj.r.squared
    r_list[i] <- adj_r_sqrd
  }
  return(r_list)
  }
```
```{r Coefficients}
coef_matrix <- function(processed_data){
  coef_matrix <- matrix(NA,
                        nrow = length(processed_data),
                        ncol = length(processed_data[[1]]) - 1,
                        dimnames = list(names(processed_data), names(processed_data[[1]])[-1]))
  for (i in 1:length(processed_data)){
    fit <- lm(OUTPUT ~ ., data = processed_data[[i]])
    coef <- as.data.frame(summary(fit)$coef)[-c(1), ]
    sig <- coef[coef$`Pr(>|t|)` < 0.05, ]
    if (nrow(sig) > 0){
      for (j in 1:nrow(sig)){
        group_name <- row.names(sig)[j]
        group_name <- substr(group_name, 1, nchar(group_name) - 4)
        coef_matrix[i, group_name] <- sig[j, 1]
      }
    }
  }
  return(coef_matrix)
}
```
And finally a plotting function to bring everything together.
```{r Plots}
library(gplots) # bluered
library(pheatmap)

plotting <- function(processed_data){
  Adjusted_R_Squared <- adj_r_sqrd(processed_data)
  CoefMatrix <- coef_matrix(processed_data)
  pheatmap(CoefMatrix,
           cluster_rows = FALSE,
           cluster_cols = FALSE,
           color = bluered(9),
           annotation_row = as.data.frame(Adjusted_R_Squared),
           angle_col = 315,
           breaks = c(seq(min(CoefMatrix, na.rm = TRUE), 0, length = 5), seq(0.000001, max(CoefMatrix, na.rm = TRUE), length = 5)),
           na_col = 0
           )
}
```

# Results

let's take a look at our results:
```{r SNV_pathways}
# SNV_pathways <- process(SNV_data, pathways_list)
# save(x = SNV_pathways, file = "SNV_pathways.RData")
load("SNV_pathways.RData")

plotting(SNV_pathways)
```
Here we can see that the maximum adjusted r squared was about 0.2 and that the most interesting pathway used is the Genome integrity pathway which has a (positive) significant coefficient in 1/3 of the cancer types studied (the most out of all the pathways).

Let's do the same but using a different kind of grouping, geneSets, which is a list of 7 groups with a total of 2953 genes.
```{r SNV_geneSets}
# Different grouping of genes
load("geneSets.Rdata")
for (i in 1:length(geneSets)){
  geneSets[[i]] <- as.list(geneSets[[i]][1][, 1])
}

# SNV_geneSets <- process(SNV_data, geneSets)
# save(x = SNV_geneSets, file = "SNV_geneSets.RData")
load("SNV_geneSets.RData")

plotting(SNV_geneSets)
```
Here we can see that, overall, the model fits the data a little worse than before (because the maximum adjusted r squared decreased from 0.2 to 0.15).
We can also see that none of the groups had a consistent coefficient through the cancer types, since all of them have both positive and negative coefficients.
This can be explained because since there are less groups (about a half), more genes (about 30 times more) and each group is only represented as absent or present, the probability of each group being present randomly is greater.